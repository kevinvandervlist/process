\chapter{Making Software \cite{makingsoftware}}
\section{Chapter 22: The evidence for design patterns}
\subsection{Notes}
% Relevant notes
Design patterns are a standard approach to solving a generic problem. 
It is like a algorithm from a text book. 
The general approach is given, but the implementation must still be tailored to the used language, framework and case. 

The added value of design patterns lies in its cognitive value. 
When a person is aware of the pattern, the meaning of it can be reduced to a single chunk (see Miller's paper). 
The rest of the short term memory is therefore still available for use.

Because the above is based on the assumption of \emph{knowing} the pattern, a warning is in place. 
When users are not aware of the patterns, they tend to increase the cognitive load of the approach. 
Another pitfall is the risk of over-engineering. 
People might become a bit overenthusiastic and start to complicate simple cases by enforcing a set of patterns which might not even be needed.

The rest of the chapter contains a lot of references on the statistical guarantees of studies regarding the use of patterns. 
Things like how to do a proper setup, prevent the learning effect and making sure research is statistically significant are mentioned as well.

\subsection{Questions}
% Relevant questions
\begin{itemize}
  \item Why to apply design patterns?
  \item Are design patterns effective?
  \item How to do a comparative research to applying design patterns?
\end{itemize}

\subsection{Review}
% Optional: review why fellow students have to read it
Read this chapter if you want to know whether design patterns can be effective or if they are a class of over-engineering.
The research to answer this question is quite extensive, and in this chapter a nice summary is presented. 
It also provides some interesting pointers if you want to do a study on something related, and statistical significance is of great importance.
Finally, some references regarding cognitive psychology might also be of interest.


\section{Chapter 07: Why Is It So Hard to Learn to Program?}
\subsection{Notes}
% Relevant notes
Apparently a large difference between natural language and ``foreign'' program language. 
A lot of people fail CS1, but when focusing on core concepts students are apt. 
Several research groups have tried other approaches, like visual programming (increased cognitive load) and ``practical, media oriented'' (worked very well. Significantly highers passing ratings of courses).
No definitive proof, but media computation tends to provide enough context so students are able to ``get'' core programming concepts easier. 

\subsection{Questions}
% Relevant questions
\begin{itemize}
  \item Why do a lot of people struggle while starting programming?
\end{itemize}

\subsection{Review}
% Optional: review why fellow students have to read it
Interesting for some nice background on why learning to program is often experienced as ``abstract'', and ``not suited for me''. 

\section{Chapter 15: Quality Wars: Open Source Versus Proprietary Software}
\subsection{Notes}
% Relevant notes
Hardly any really comparing research exists, because companies are usually not willing to provide source for such analyses.
The author of the chapter took matter into his own hands, and defined a large list of metrics on which four important projects could be compared. 
Relevance of the metrics will not be discussed here, see all I've learned during Software Evolution. 

The four used projects are an academic release of the Windows, OpenSolaris, Linux and FreeBSD.
More specifically, it always was the kernel of  those systems. 
These projects are of comparable size and complexity (except for missing drivers in the case of windows) so they can be compared. 

A huge list of metrics is generated, and overall there is no winner or loser. 
Each project had focus on different aspects of the code quality, and that can be seen. 
None of them were bad, the managerial approaches just differed. 

\subsection{Questions}
% Relevant questions
\begin{itemize}
  \item Can you say that open source (kernel) code quality is higher then proprietary counterpart?
\end{itemize}

\subsection{Review}
% Optional: review why fellow students have to read it
Read this chapter if you are interested in metrics of huge projects.
It's an interesting read, but the conclusions are not shocking.

\section{Chapter 16: Code Talkers}
\subsection{Notes}
% Relevant notes
The central topic in this chapter is how much developers communicate, and what the content of this communication is. 
Several studies are described, initially conducted in a waterfall-style programming environment. 
In general, the result was that developers work on code, realise they miss certain information required to solve the problem at hand, and then try to acquire it. 

This acquiring can happen via talking (e.g. interrupting) to colleagues.
The question that rises then is whether this is harmful for an organisation or not. 
In general, this is regarded as not harmful, since developers tend to interrupt only for non-trivial questions (they perform a kind of basic study of the environment).
While no answer has been found, their task at hand is basically blocked. 

The chapter ends with a little Agile approach comparison. 
Generally, communications in an open work floor are more work related, and tend to be shorter. 
Because developers can quickly jump in if they have a question, information can be gathered quicker. 
The downside of this is the lack of codifying. 
In the chapter this is presented as a future research subject. 

In short: the author thinks all this communication is definitely worth it's timely investments. 

\subsection{Questions}
% Relevant questions
\begin{itemize}
  \item Why do developers communicate so much?
  \item What does ``average'' communication consist of?
  \item Future: Does this effect also occurs in an agile environment?
\end{itemize}

\subsection{Review}
% Optional: review why fellow students have to read it
This chapter provides a nice insight in the social and communication aspects of a programmers job. 
If you are interested, this definitely will be a good read. 
In my case, it contained quite a few eye openers (implicit different approaches to ``interrupting'' problem. 

\section{Chapter 24: The Art of Collecting Bug Reports}
\subsection{Notes}
% Relevant notes
The content of this chapter is focused on gathering and creating bug reports, and judging how effective they can be sold. 
By questioning both users and developers of large projects, the authors made lists containing items that are deemed important by both users and developers. 

Interestingly, there is a \emph{correlation} between items that both users and developers deem important for bug fixing.
However, the \emph{opposite} is true for what users know is important and what they \emph{provide} in a bug report. 
In other words, they know what is important, but consciously leave it out of reports. 

Another factor they researched is whether bug duplicates are harmful (as stated by previous research). 
Their findings are the opposite. 
When duplicates are seen as other approaches to describing the same problem, they can be seen as added value because of the differing content. 
Duplicate bug reports increased the amount of information on the issue in basically all cases, even when marked as duplicate.

The chapter ends with the summary that in general the following is true.
Bug reports with stack traces, that are easier to read and having applied code samples get fixed sooner.
A last piece of advice is to emphasise the importance of the information that is of great importance to developers, even though users generally know it.

\subsection{Questions}
% Relevant questions
\begin{itemize}
  \item What is considered a good bug report by developers?
  \item What is considered a good bug report by users?
  \item What can be done to decrease the longevity of bug reports?
  \item Are duplicate bug reports harmful?
\end{itemize}

\subsection{Review}
% Optional: review why fellow students have to read it
If you are interested in bug reports or bug reporting this is a very good read. 
If you want to know how to improve the quality of bug reports of users, this is an even better read. 
The work is really interesting, since it is a very common problem all developers will encounter. 
The chapter itself is an easy read, but contains terrific information.

I highly recommend this chapter.

\section{Chapter 29: How Usable Are Your APIs?}
\subsection{Notes}
% Relevant notes
As the central topic, API design is chosen in this chapter. 
API design is important, because it is used a lot of times, based on the assumption of saving time. 
When an API is hard to use, this is not the case, and can even result in the opposite situation. 
In general, developers don't tend to blame API design, but their own lack of understanding (``I'm not sufficient enough, give me some time'').

Designing a good API is important, and doing it correctly is hard. 
A first approach to discover a sort of general model in an API domain is done by a ``card stacking''\footnote{Grouping cards with functionality, trying to discover model patterns} experiment.
This resulted in total chaos, but provided the insight that everybody uses API in their own way. 
There is hardly a common domain from API usability perspective

A second study was focused on the level of abstractness used by the API in question\footnote{VB.Net}.
The main findings of this were not that an API was hard to use, and therefore might require more code examples as one might suspect, but that the level of abstractness might be too high.
If the domain of an API does not match the domain of the users, cognitive load is high.

By using the \emph{Cognitive Dimensions Framework}, mappings were made to \emph{personas}, styles of programmers identified as the audience for the API in question.
As it turned out, each persona had its unique characteristics in the framework, and the API did not address this.

The API was adapted by adding various ``layers'' of basically increasing abstraction. 
This resulted in an API, which all of their target audience could use, while still retaining an enormous amount of flexibility. Not the \emph{design} of the architecture, but the \emph{user experience} is the most important part of API design.

\subsection{Questions}
% Relevant questions
\begin{itemize}
  \item What is good API design?
  \item How to evaluate API design?
\end{itemize}

\subsection{Review}
% Optional: review why fellow students have to read it
Read this chapter if you are interested in making your APIs usable for other developers. 
It contains a lot of pointers and a short introduction towards evaluation of API usage of your targeted developers. 
Other then that it is an easy read, and makes you see programming from another perspective (programming for \emph{other developers} instead of \emph{users}.
