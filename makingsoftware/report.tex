\documentclass[]{uva-bachelor-thesis}

% Define this when starting to use the template:
\def\course{Software Process}
\def\assignment{Assignment 5: Making Software Essays}
\def\group{Kevin van der Vlist}
\def\duedate{\today}
% Define your team members hear, each one on a row:
\def\teamtable{\begin{tabular}{ll}
10338152 & kevin.vandervlist@student.uva.nl \\
\end{tabular}}
% The document is now set correctly

\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{url}
\usepackage{eurosym}

\usepackage{fancyhdr}
\usepackage[colorlinks, linkcolor=black, urlcolor=black, citecolor=black]{hyperref}
\usepackage{fancyhdr}
\setlength{\headheight}{15pt}

% Chapter and page storage
\def \CurrChapter {}
\def \LastSection {}
\def \CurrSection {}
\newcounter{CurrPage}
\setcounter{CurrPage}{0}

\pagestyle{fancy} 
\renewcommand{\markboth}[2]{\def \CurrChapter {#1}} % For use with \tableofcontents
\renewcommand{\chaptermark}[1]{\def \CurrChapter {#1} \def \CurrSection {}}
\renewcommand{\sectionmark}[1]{ %
  \ifthenelse{ %
    \equal{\thepage}{\value{CurrPage}} %
  } %
  {\def \CurrSection {: #1}} %
  {\let \LastSection \CurrSection \def \CurrSection {: #1} \setcounter{CurrPage}{\value{page}}} %
}

% Headers and footers
\renewcommand{\footrulewidth}{0.5pt}

\fancyhf{}
\fancyfoot[LE,RO]{\textit{\thepage}}
\fancyfoot[RE,LO]{\textit{\group}}
\fancyhead[RE,LO]{\textit{}}
\fancyhead[LE,RO]{ %
  \ifthenelse{ %
    \equal{\thepage}{\value{CurrPage}} %
  } %
  {\textit{\nouppercase{\CurrChapter\LastSection}}} %
  {\let \LastSection \CurrSection \textit{\nouppercase{\CurrChapter\LastSection}}} %
}

\fancypagestyle{plain}{ %
\fancyhf{} %
\fancyfoot[LE,RO]{\textit{\thepage}} %
\fancyfoot[RE,LO]{\textit{\group}} %
\renewcommand{\headrulewidth}{0pt} % remove lines as well
}

\setlength{\parskip}{.5em}

\title{\course}
\subtitle{\assignment}
\author{\group}
\team{\teamtable}

\begin{document}
\maketitle

\setlength{\parskip}{0px}
\tableofcontents
\setlength{\parskip}{.5em}

\clearpage

\chapter{Chapter 07: Why Is It So Hard to Learn to Program? \cite{makingsoftware}}
% How can you use this knowledge to understand project success and failure?
Apparently a large difference between natural language and ``foreign'' program language. 
A lot of people fail CS1, but when forced to focus on purely core concepts students show quality. 
Several research groups have tried other approaches, like visual programming (increased cognitive load) and ``practical, media oriented'' (worked very well. Significantly highers passing ratings of courses).
No definitive proof, but media computation tends to provide enough context so students are able to ``get'' core programming concepts easier. 

If the content of this chapter will be generalised, one might hypothesise that this also holds for general new domains. 
A project that needs to accomplish something in a certain domain first needs to be sure that every intricacy will be conquered.
Everything needs to be captured in the ubiquitous language and (mental) models a project team is using.

In cases of project failure, a lot of things can go wrong. 
One example is the case where most of the domain is new (like with the Betuwelijn). 
Challenges that are part of a project need to be analysed and a solution for completion needs to be developed. 

In larger projects there are a lot of people working relatively ``far'' from the real problem. 
This automatically introduces a higher level of abstraction and more distance from the actual situation. 
If the situation is not under control (because it's new, and not routine) this might introduce problems, and the same problems from the chapter can start to occur. 

A way to prevent the problem could be to create structured guidelines for new situations.
This could force an organisation to keep control of their ``abstractionness''. 
The second thing that needs to be done is making sure \emph{different} approaches will be taken to analyse a problem which is new. 
This forces to approach the problem from different angles, increasing the chances of forming a coherent model.
If this is applied over a period of time, a generic and improved approach might be formalised to take the lessons learned into account.

\chapter{Chapter 15: Quality Wars: Open Source Versus Proprietary Software \cite{makingsoftware}}
% How can you use this knowledge to understand project success and failure?
Central in this chapter of the book is whether you can objectively judge the quality in open source and proprietary software.
The take home message is that this \emph{can} be the case, if the metrics you use are actually meaning something of importance to specific quality attribute you want to test. 
In the chapter, the author chooses a large list of software metrics to evaluate quality with, and analysis four huge projects, two proprietary and two open source. 
His main conclusion: In these projects, the quality between open source and proprietary software is non existent.

What in my opinion is really interesting is that the code show such huge differences in the way it is set up. 
The author of the study thinks this might be the case because of the different managerial approaches to the project. 
After all, FreeBSD has almost no hierarchy at all, while Microsoft is the complete opposite.

The effect of these managements upon the code is not something that has to be ignored.
As suggested in the chapter, management can force a certain angle of development upon the project, which increases quality in a certain perspective. 
This automatically means a trade off, in which some other aspect has to decrease in quality.
This will not be a problem, but shows you can use management to guide the direction of the code base, without enforcing your way of doing things.
You just provide a general nudge in the direction you want to go.

In other words, if management knows beforehand that a certain aspect of a project is risky, attention to this can be enforced. 
However, this does \emph{not} mean that you have to provide a clear-cut solution to the problem which only needs to be implemented. 
This will change your guidance to be coercive instead of enabling.
As read in \emph{Two types of bureaucracy}\cite{adler1996two} this tends to decrease the quality and the level of satisfaction of the work.

By using the knowledge described above, you are able to guide employees in a certain direction.
This can be done in a way that is \emph{enabling}, thus still preserving the freedom and creativity of cunning employees. 
The second thing that can be learned from this chapter is the well-known message that says \emph{code metrics are not the whole story}. 
Even though a lot of people know this, a lot of trust is generally put in these metrics. 
Use them, but use them wisely.

\chapter{Chapter 16: Code Talkers \cite{makingsoftware}}
% How can you use this knowledge to understand project success and failure?
In this chapter the social behaviour of programmers is studied.
As it turns out, programmers need more information then they can find in the code they are working in itself. 
Code under inspection might be complex, its design might be influenced by domain constraints that are not tacit or it might just be ``owned'' by someone else.

In order to retrieve missing information, developers tend to approach persons they know that have the information they are looking for. 
The author of the chapter goes as far as saying this is a \emph{blocking} task, in which the programmer cannot continue until the required knowledge is gathered. 
To prevent wasting extra time, programmers usually tend to preserve extra tasks to do while being blocked.

In more agile environments, the author observes that having open communication on work decreases the blocked time on waiting for information.
Open communication allows programmers to step in and ask work-related questions whenever they arise.
The downside of this is that it does not leave a paper trail. 
These talks cannot be searched and indexed, and therefore does not help in solidifying information.

In the context of project success and failure I believe this learns us two things. 
The first is that knowledge sharing is important, the second is that the specific way this communication happens is of importance as well.

Knowledge sharing itself is of great importance because it allows employees to make decisions that can systematically add value.
When a decision needs to be made on a moment in time in which multiple choices can be made, work of others can be affected. 
If those other people do not suspect these influences, or the person who makes the change is not aware of those other people, a situation can be created in which the two (or more) forces work against each other. 

If this happens, an organisation will waste its resources on ``battling'' those internal discrepancies, while no business goals will be met. 
In order to prevent such situations, improvements can be mode so employees can easily achieve the information they are looking for. 
Now, as apposed to being in an informational void, employees are able to attain the information they need, and results can be achieved.

The other learning goal is the way this communication is conducted.
This can be done in a lot of different ways, each having their individual characteristics. 
Email for example is asymmetrical (e.g. you won't have to respond directly) and leaves a paper trail which you can use as a way to retain information. 
A well known example of this is the concept of a mailing list. 

On the other hand, communication which is more informal, like a work-related talk at the coffee machine can also convey a lot of information. 
A consequence of such channels is that information transfer is volatile. 
Only the people in the conversation will remember the content, and even they will forget over time. 
If information within an organisation is of great value, effort must be put in solidifying this knowledge, or it will be lost over time and cannot be used to educate others. 

To summarise, information is of great importance of people within an organisation. 
Not having information can be a hindrance, and requiring it has different effects on colleagues based on the communication channel used. 
Next to being a hindrance, lack of information can be downright misleading or even counter productive, jeopardising the production result of a company as a whole.
Special care must be taken that core knowledge will be solidified, so it is always available to the information. 

\chapter{Chapter 24: The Art of Collecting Bug Reports \cite{makingsoftware}}
% How can you use this knowledge to understand project success and failure?
The core subject of this chapter is a study on the quality of bug reports, and a survey on why the quality varies.
In short, findings are that end users filing bug reports are \emph{aware} of information needs of developers, but \emph{ignore} those needs when filing such a report.
The result of this behaviour is that bugs found by users are hard to fix, because crucial information is missing. 

When the bugs are harder to fix, more of them will remain in a product. 
Because of this, the experienced quality will probably be lower as well. 
Users see decoration of their tool, and issues they provide are discarded. 

This low product quality can become an issue if users start to blame a software tool for harming their job. 
Instead of providing extra value, a tool might then become a nuisance, resulting in wasted time and energy. 
If this happens, the image of the backing company will be affected as well. 

The whole process might even become a negative spiral, in which each phase will strongly influence all the phases that follow the current one.
In order to improve upon such a situation, and thereby help the success rate of a project, effort can be put in collecting bug reports that are of use. 
Providing the ``right'' and needed information must be stimulated, and things like duplicate bug reports should not be closed without thinking about it. 
Such reports can add information to an issue if the duplicates are seen as a set of issue descriptions. 

If an organisation can make users provide worthwile bug reports, the experienced quality a product can be enhanced.
This will positively influence the vision users have of a product, which will contribute positively to the evaluation of a product. 
It therefore positively influences a project, and might even create the difference between project failure and success.

\chapter{Chapter 29: How Usable Are Your APIs? \cite{makingsoftware}}
% How can you use this knowledge to understand project success and failure?

\bibliographystyle{abbrv}
\bibliography{references}
\chaptermark{Bibliography}

\end{document}
