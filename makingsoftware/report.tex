\documentclass[]{uva-bachelor-thesis}

% Define this when starting to use the template:
\def\course{Software Process}
\def\assignment{Assignment 5: Making Software Essays}
\def\group{Kevin van der Vlist}
\def\duedate{\today}
% Define your team members hear, each one on a row:
\def\teamtable{\begin{tabular}{ll}
10338152 & kevin.vandervlist@student.uva.nl \\
\end{tabular}}
% The document is now set correctly

\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{url}
\usepackage{eurosym}

\usepackage{fancyhdr}
\usepackage[colorlinks, linkcolor=black, urlcolor=black, citecolor=black]{hyperref}
\usepackage{fancyhdr}
\setlength{\headheight}{15pt}

% Chapter and page storage
\def \CurrChapter {}
\def \LastSection {}
\def \CurrSection {}
\newcounter{CurrPage}
\setcounter{CurrPage}{0}

\pagestyle{fancy} 
\renewcommand{\markboth}[2]{\def \CurrChapter {#1}} % For use with \tableofcontents
\renewcommand{\chaptermark}[1]{\def \CurrChapter {#1} \def \CurrSection {}}
\renewcommand{\sectionmark}[1]{ %
  \ifthenelse{ %
    \equal{\thepage}{\value{CurrPage}} %
  } %
  {\def \CurrSection {: #1}} %
  {\let \LastSection \CurrSection \def \CurrSection {: #1} \setcounter{CurrPage}{\value{page}}} %
}

% Headers and footers
\renewcommand{\footrulewidth}{0.5pt}

\fancyhf{}
\fancyfoot[LE,RO]{\textit{\thepage}}
\fancyfoot[RE,LO]{\textit{\group}}
\fancyhead[RE,LO]{\textit{}}
\fancyhead[LE,RO]{ %
  \ifthenelse{ %
    \equal{\thepage}{\value{CurrPage}} %
  } %
  {\textit{\nouppercase{\CurrChapter\LastSection}}} %
  {\let \LastSection \CurrSection \textit{\nouppercase{\CurrChapter\LastSection}}} %
}

\fancypagestyle{plain}{ %
\fancyhf{} %
\fancyfoot[LE,RO]{\textit{\thepage}} %
\fancyfoot[RE,LO]{\textit{\group}} %
\renewcommand{\headrulewidth}{0pt} % remove lines as well
}

\setlength{\parskip}{.5em}

\title{\course}
\subtitle{\assignment}
\author{\group}
\team{\teamtable}

\begin{document}
\maketitle

\setlength{\parskip}{0px}
\tableofcontents
\setlength{\parskip}{.5em}

\clearpage

\chapter{Chapter 07: Why Is It So Hard to Learn to Program? \cite{makingsoftware}}
% How can you use this knowledge to understand project success and failure?
Apparently a large difference between natural language and ``foreign'' program language. 
A lot of people fail CS1, but when forced to focus on purely core concepts students show quality. 
Several research groups have tried other approaches, like visual programming (increased cognitive load) and ``practical, media oriented'' (worked very well. Significantly highers passing ratings of courses).
No definitive proof, but media computation tends to provide enough context so students are able to ``get'' core programming concepts easier. 

If the content of this chapter will be generalised, one might hypothesise that this also holds for general new domains. 
A project that needs to accomplish something in a certain domain first needs to be sure that every intricacy will be conquered.
Everything needs to be captured in the ubiquitous language and (mental) models a project team is using.

In cases of project failure, a lot of things can go wrong. 
One example is the case where most of the domain is new (like with the Betuwelijn). 
Challenges that are part of a project need to be analysed and a solution for completion needs to be developed. 

In larger projects there are a lot of people working relatively ``far'' from the real problem. 
This automatically introduces a higher level of abstraction and more distance from the actual situation. 
If the situation is not under control (because it's new, and not routine) this might introduce problems, and the same problems from the chapter can start to occur. 

A way to prevent the problem could be to create structured guidelines for new situations.
This could force an organisation to keep control of their ``abstractionness''. 
The second thing that needs to be done is making sure \emph{different} approaches will be taken to analyse a problem which is new. 
This forces to approach the problem from different angles, increasing the chances of forming a coherent model.
If this is applied over a period of time, a generic and improved approach might be formalised to take the lessons learned into account.

\chapter{Chapter 15: Quality Wars: Open Source Versus Proprietary Software \cite{makingsoftware}}
% How can you use this knowledge to understand project success and failure?
Central in this chapter of the book is whether you can objectively judge the quality in open source and proprietary software.
The take home message is that this \emph{can} be the case, if the metrics you use are actually meaning something of importance to specific quality attribute you want to test. 
In the chapter, the author chooses a large list of software metrics to evaluate quality with, and analysis four huge projects, two proprietary and two open source. 
His main conclusion: In these projects, the quality between open source and proprietary software is non existent.

What in my opinion is really interesting is that the code show such huge differences in the way it is set up. 
The author of the study thinks this might be the case because of the different managerial approaches to the project. 
After all, FreeBSD has almost no hierarchy at all, while Microsoft is the complete opposite.

The effect of these managements upon the code is not something that has to be ignored.
As suggested in the chapter, management can force a certain angle of development upon the project, which increases quality in a certain perspective. 
This automatically means a trade off, in which some other aspect has to decrease in quality.
This will not be a problem, but shows you can use management to guide the direction of the code base, without enforcing your way of doing things.
You just provide a general nudge in the direction you want to go.

In other words, if management knows beforehand that a certain aspect of a project is risky, attention to this can be enforced. 
However, this does \emph{not} mean that you have to provide a clear-cut solution to the problem which only needs to be implemented. 
This will change your guidance to be coercive instead of enabling.
As read in \emph{Two types of bureaucracy}\cite{adler1996two} this tends to decrease the quality and the level of satisfaction of the work.

By using the knowledge described above, you are able to guide employees in a certain direction.
This can be done in a way that is \emph{enabling}, thus still preserving the freedom and creativity of cunning employees. 
The second thing that can be learned from this chapter is the well-known message that says \emph{code metrics are not the whole story}. 
Even though a lot of people know this, a lot of trust is generally put in these metrics. 
Use them, but use them wisely.

\chapter{Chapter 16: Code Talkers \cite{makingsoftware}}
% How can you use this knowledge to understand project success and failure?
In this chapter the social behaviour of programmers is studied.
As it turns out, programmers need more information then they can find in the code they are working in itself. 
Code under inspection might be complex, its design might be influenced by domain constraints that are not tacit or it might just be ``owned'' by someone else.

In order to retrieve missing information, developers tend to approach persons they know that have the information they are looking for. 
The author of the chapter goes as far as saying this is a \emph{blocking} task, in which the programmer cannot continue until the required knowledge is gathered. 
To prevent wasting extra time, programmers usually tend to preserve extra tasks to do while being blocked.

In more agile environments, the author observes that having open communication on work decreases the blocked time on waiting for information.
Open communication allows programmers to step in and ask work-related questions whenever they arise.
The downside of this is that it does not leave a paper trail. 
These talks cannot be searched and indexed, and therefore does not help in solidifying information.

In the context of project success and failure I believe this learns us two things. 
The first is that knowledge sharing is important, the second is that the specific way this communication happens is of importance as well.

Knowledge sharing itself is of great importance. 

The way this is done.

\chapter{Chapter 24: The Art of Collecting Bug Reports \cite{makingsoftware}}
% How can you use this knowledge to understand project success and failure?

\chapter{Chapter 29: How Usable Are Your APIs? \cite{makingsoftware}}
% How can you use this knowledge to understand project success and failure?

\bibliographystyle{abbrv}
\bibliography{references}
\chaptermark{Bibliography}

\end{document}
